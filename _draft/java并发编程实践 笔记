java并发编程实践 笔记

1.无状态的类总是线程安全的
2.假设有操作A和B，从执行A的线程角度看，当其他线程执行B时，要么B全部执行完成，要么一点没有执行，这样A和B互为原子操作。
3.每个对象都有一个内部锁intrinsic lock或称监视器锁monitor lock,获得内部锁的唯一途径是进入这个内部锁保护的同步快或方法
4.内部锁是可重进入的，线程请求它已经占有的锁时，请求会成功。每个锁关联一个请求计数器和占有它的线程。
5.不要为了性能而向安全性妥协，性能扩展办法很多，线程不安全将可能引发灾难。
6.在没有同步的情况下，编译器生成的指令顺序和处理器执行的指令顺序可能与代码中的执行顺序都不相同
7.锁不仅关于同步和互斥，也是关于内存可见的。为了保证共享变量的最新值对所有线程可见，读写操作必须使用共享变量的锁进行同步。
8.对volatile变量的操作不会重排序。
9.volatile变量：用于确保对象状态的可见性，或者用于标识重要生命周期时间的发生。（也就是说volatile变量更适合做状态值，不适于同步的实现）
10.加锁保证可见性和操作原子性，volatile只保证可见性。
11.关于对象的发布(publishing)和逸出(escape)，对于引用型变量应特别重视。
12.this引用在构造期间逸出会导致不可预估问题。构造函数中启动一个线程或者调用一个可重写方法时都会导致this逸出
13.不可变对象满足三个条件：1.状态创建后不可修改；方法为fianl不可重写；被正确创建
14.不可变对象中的引用变量，get和set方法引入clone
15.安全发布对象，对象的引用和状态必须对其他线程可见：1.通过静态初始化器初始化对象引用；2.将引用存储到volatile或AtomicReference；3.将引用存储到final域中；4.将引用存储到锁中
16.线程安全Collection：HashSet,synchronizedMap,ConcurrentMap,Vector,CopyOnWriteArrayList,CopyOnWriteArraySet,SynchronizedList,SynchronizedSet,BlockingQueue,ConcurrentLinkedQueue
17.共享对象原则：线程独享对象(线程内部变量)；只读对象(不可变对象)；线程安全对象(自身满足线程安全)；带锁对象
18.对象的状态就是它的数据。
19.当多个线程访问同一个对象时，不需要考虑线程调度和代码调整，对象的行为总是正确的，称这个对象线程安全。线程安全的对象已经封装了任何必要的同步，客户不需要自己提供。
20.Collections.unmodifiableMap提供一个Map的view